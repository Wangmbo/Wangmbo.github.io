[{"categories":["note"],"content":"前言 Store 是什么 Store是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定，它承载着全局的状态 什么时候使用Store 一个Store应该包含可以在整个应用中访问的数据，例如显示在导航栏中的用户信息，以及需要通过页面保存的数据，例如一个非常复杂的多步骤表单。应该避免在Store中引入那些本可以在组件中保存的本地数据，例如，一个元素在页面中的可见性。 ","date":"2023-01-14","objectID":"/posts/pinia-use/:0:1","tags":["pinia"],"title":"pinia使用手册","uri":"/posts/pinia-use/"},{"categories":["note"],"content":"使用 创建pinia实例(根store)，然后将其挂载到app上 // mian.ts import { createPinia } from 'pinia' const pinia = createPinia() app.use(pinia) 声明store // useTodoList.ts import { defineStore } from 'pinia' export const useTodoList = defineStore('todoList', { // state // getters // actions }) 使用store import { useTodoList } from '@/store/useTodoList' const todoListStore = useTodoList() 修改state actions中修改 直接修改 $patch $reset 订阅state $subscribe store.$subscribe((mutation, state) =\u003e { }) watch 监听 插件的使用 import { createPinia } from 'pinia' // 创建的每个 store 中都会添加一个名为 `secret` 的属性。 // 在安装此插件后，插件可以保存在不同的文件中 function SecretPiniaPlugin() { return { secret: 'the cake is a lie' } } const pinia = createPinia() // 将该插件交给 Pinia pinia.use(SecretPiniaPlugin) // 在另一个文件中 const store = useStore() store.secret // 'the cake is a lie' 插件中的参数 export function myPiniaPlugin(context) { context.pinia // 用 `createPinia()` 创建的 pinia。 context.app // 用 `createApp()` 创建的当前应用(仅 Vue 3)。 context.store // 该插件想扩展的 store context.options // 定义传给 `defineStore()` 的 store 的可选对象。 // ... } ","date":"2023-01-14","objectID":"/posts/pinia-use/:0:2","tags":["pinia"],"title":"pinia使用手册","uri":"/posts/pinia-use/"},{"categories":["note"],"content":"基本概念 在进入到移动端适配的方案之前先了解几个基本概念 像素 像素就是构成图像的最小单位，指显示屏上的最小单位，图像由相随组成，单位面积内的像素越多，效果就越好。像素大小不是绝对的，是根据设备的分辨率决定的。 分辨率 屏幕分辨率，屏幕横向和纵向的像素点数，单位为px 相同大小的屏幕，分辨率越低，单位像素尺寸越大，分辨率越高，单位像素尺寸越小 图像分辨率：指图片含有的像素数，表示图片分别在垂直和水平上所具有的像素点数 同一尺寸的图片，分辨率越高，图片越清晰 设备物理像素 设备的真实分辨率，屏幕有多少个像素点，就是多少分辨率 设备独立像素 一种单位来告诉不同分辨率的手机，他们在界面上显示元素的大小是多少，即设备几个物理像素当成一个像素使用 设备像素比 DPR 物理像素比设备独立像素的比值 css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的，1px并不是绝对的，它只代表了当前设备像素的最小单位 在PC端 1px等于一个设备的物理像素，但是移动设备的屏幕像素密度越来越高，iphone6上一个css像素是等于两个物理像素，通过dpr，我们可以知道该设备上一个css像素代表多少个物理像素。 css像素 css像素，当页面缩放比例为100%时，一个css像素等于一个设备独立像素，但是css像素是很容易被改变的，当用户对浏览器进行了放大，css像素会被放大，这时一个css像素会跨越更多的物理像素。 理想视口 布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。 PC window.screen.width 移动端 \u003cmeta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;\"\u003e 该meta标签的作用是让当前布局视口的宽度等于设备的宽度，同时不允许用户手势缩放。视觉视口等于理想视口的时候，1个css像素就等于1个设备独立像素。 css度量单位 em 相对单位，表示当前元素的字体大小 rem 相对单位，表示根元素(html元素)的字体大小 % 相对父元素的百分比 vw 相对单位，相对视口宽度的百分比 vh 相对单位，相对视高度的百分比 vmin 视口宽度和高度较小值的百分比 vmax 视口宽度和高度较大值的百分比 ","date":"2022-09-25","objectID":"/posts/mobile/fit/:0:1","tags":["移动端"],"title":"移动端适配","uri":"/posts/mobile/fit/"},{"categories":["note"],"content":"适配方案 rem适配 flexble 适配方案 媒体查询 + rem vw + rem 布局 ","date":"2022-09-25","objectID":"/posts/mobile/fit/:0:2","tags":["移动端"],"title":"移动端适配","uri":"/posts/mobile/fit/"},{"categories":["note"],"content":"前言 很早之前就听说了webpack5的模块联邦，对它提供的应用之间模块级共享能力还挺感兴趣的，但一直还没有使用起来，本文会以5W1H的模式来围绕模块联邦做一个学习分享。 ","date":"2022-08-25","objectID":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/:0:1","tags":["webpack"],"title":"深入浅出Webpack5模块联邦","uri":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/"},{"categories":["note"],"content":"Who 本文的目标读者是对模块联邦感兴趣但未使用过/不了解其原理的开发同学 ","date":"2022-08-25","objectID":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/:0:2","tags":["webpack"],"title":"深入浅出Webpack5模块联邦","uri":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/"},{"categories":["note"],"content":"What 是webpack5的新特性，允许多个webpack编译产物之间共享模块、依赖、甚至应用 提供了一种轻量级的、在运行时，通过全局变量组合，在不同模块之前进行数据的获取 提供了一种解决应用集的官方方案。每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。 ","date":"2022-08-25","objectID":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/:0:3","tags":["webpack"],"title":"深入浅出Webpack5模块联邦","uri":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/"},{"categories":["note"],"content":"Where 每个页面单独构建 单页应用的每个页面都是在单独的构建中从容器暴露出来。主体应用程序也是独立构建，会将所有页面作为远程模块引用。通过这种方式，可以单独部署每个页面。在更新路由或者添加新路由时部署主体应用程序。主体应用程序将常用库定义为共享模块，以避免在页面构建中重复出现。 将组件库作为容器 许多应用程序共享一个通用的组件库，可以将其构建成暴露所有组件的容器。每个应用程序使用来自组件库容器的组件。 When \u0026 Why 公共模块复用 我们有A, B, C三个项目，针对这三个的一些公共模块，在进行组件/方法复用的时候，B项目抽离出公共的模块打包成npm包，通过发包的方式进行组件/方法复用。这样是没有问题的，但是当面临这个npm包的更新时，尤其是修复了bug时，我们不得不通知依赖模块进行升级，这样一个一个项目升级的模式肯定是低效率的。 解决方案： 实现原理 How 可参考的简单demo 官方demo 核心配置字段 name name表示当前应用的别名，当作为remote时被host引用时需要在路径前加上这个前缀。 filename filename表示remote应用提供给host应用使用时的入口文件，比如上面component应用设置的是remoteEntry，那么在最终的构建产物中就会出现一个remoteEntry的入口文件供main应用加载。 exposes exposes表示remote应用有哪些属性、方法和组件需要暴露给host应用使用，他是一个对象，其中key表示在被host使用的时候的相对路径，value则是当前应用暴露出的属性的相对路径。 remote remote 表示当前host应用需要消费的remote应用的以及他的地址，他是一个对象，key为对应remote应用的name值，这里要注意这个name不是remote应用中配置的name，而是自己为该remote应用自定义的值，value这是remote应用的资源地址。 shared 当前应用无论是作为host还是remote都可以共享依赖，而共享的这些依赖需要通过shared去指定 ","date":"2022-08-25","objectID":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/:0:4","tags":["webpack"],"title":"深入浅出Webpack5模块联邦","uri":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/"},{"categories":["note"],"content":"参考文档 一文通透讲解webpack5 module federation 最详细的Module Federation的实现原理讲解 ","date":"2022-08-25","objectID":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/:0:5","tags":["webpack"],"title":"深入浅出Webpack5模块联邦","uri":"/posts/webpack/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack5%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/"},{"categories":["analyse"],"content":" 复盘最近几周工作、学习、健身等，主要有两个关键字执行力和专注力 ","date":"2022-08-07","objectID":"/posts/20220807-analyse/:0:0","tags":null,"title":"20220807-复盘H1","uri":"/posts/20220807-analyse/"},{"categories":["analyse"],"content":"工作 工作上最近都在做业务需求，个人相对比上个季度来说对业务的理解和需求的把控都有所增强。 需加强： 架构能力 =\u003e 分析业务、需求之后，能够产出架构方案设计 工作效率 =\u003e 受执行力和专注力影响，工作效率未达到预期 ","date":"2022-08-07","objectID":"/posts/20220807-analyse/:0:1","tags":null,"title":"20220807-复盘H1","uri":"/posts/20220807-analyse/"},{"categories":["analyse"],"content":"学习 最大的问题是，学的东西较为零散，也没有将所学的知识进行实际的产出或巩固。 需加强： 专注学习某项技术，产出文章/工具/产品 ","date":"2022-08-07","objectID":"/posts/20220807-analyse/:0:2","tags":null,"title":"20220807-复盘H1","uri":"/posts/20220807-analyse/"},{"categories":["analyse"],"content":"健身 由于拖延症等原因，导致晚上睡得晚，早上的锻炼状态并不好 容易被自己感动，应该加强锻炼强度 需加强： 早睡，尽量在00:30前开始入睡 加强锻炼强度，严格按照keep组间动作的休息时间 ","date":"2022-08-07","objectID":"/posts/20220807-analyse/:0:3","tags":null,"title":"20220807-复盘H1","uri":"/posts/20220807-analyse/"},{"categories":["analyse"],"content":"总结 定好目标后，需要加强自己的执行力，在执行的过程中需要提升自己的专注力，这样才能有效率的达成目标。 如何提升专注力 尽量减少自己多线程做事 分心最大的敌人是自己，逃避困难，缓解和逃避痛感 =》通过冥想去驱赶逃避的想法和行为 ","date":"2022-08-07","objectID":"/posts/20220807-analyse/:0:4","tags":null,"title":"20220807-复盘H1","uri":"/posts/20220807-analyse/"},{"categories":["Read notes"],"content":" 当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要一种，在两种学习模式（专注和发散）之间来回切换的能力。 番茄工作法，克服拖延症 集中精力25min =》 小奖励 练习在数学和科学中学到的思想和概念是很重要的，越是抽象的东西，越是需要反复练习。 加强神经元模式，熟能生巧 工作记忆 需要不断重复转换为长期记忆 间隔重复 长期记忆 存储仓库 睡觉时，大脑会将学习和思考过的想法和概念进行整理。 睡觉前复习对加深理解和记忆有帮助 实践出真知，发散思考，切换任务的能力 激情和努力 以全新的视角来学习 放大和缩小问题，会有更好的主意 对语言的热爱才会能够有足够的激励,克服困难 重复是所有学习的一部分，助记法 第一步是创建出概念组块 完全投入 对建立的组块了解基本概念 练习实际操作解决问题 根据意义将信息碎片拼接起来 反复阅读不如回顾 回顾法练习，回顾的过程中加深理解 学会总结关键概念 常规场所外回顾会加深记忆 思维定式 交替学习，让大脑更具创造力，脱离重复 学习时对能力的错觉，有意练习更加困难的部分 组块构建与避免能力错觉 组块是根据意义将信息碎片组成的合集，就像电脑把繁杂的文件放在一起，保存成.zip格式的压缩包。要熟练地掌握某项技能或者知识，就要创造一些概念组块，这是通过意义将分散的信息碎片组合起来的过程。把要处理的信息构成组块，可以使大脑更高效的运转。 构建组块 利用意义、组合起信息碎片 注意力集中在需要组块的信息上 理解基本概念，合上书本后找些问题来测验一下新学到的解题方法，会提高在本阶段的学习效率 获取背景信息，跳出出示问题，用更宽广的视角看问题。 能力错觉和回想 在学习中进行回想，让大脑提取关键概念，在下次重读开始前的间隔时间进行回想，训练大脑。 离开平时的学习地方，到别处回想材料，可以让人从不同的角度看待问题，从而增进理解 简单的内容或者已有答案的问题会让人产生能力错觉，应该要独立解决问题 与其过度学习，不如穿插学习 应该在每个学习或练习的单元时间内，把学习内容量尽量最大化，也就是应该让自己的学习时间得到超值的回报。 与其在同类技巧、概念投入太长时间学和练，不如把精力分配到更短的时间段上，并不是说学习时间长就是不好的，只要不在同类技巧或者概念投入过多精力，学习时间长并没有什么坏处。一旦理解了概念X，学习重心就应该转移到别的概念，过几天再来回顾。 总结 练习有助于构建强壮的神经模型，那就是形成理解的概念组块 构成组块必需品：集中注意力，构建基本概念，反复练习帮助获取宏观背景信息 简单回想，试着关上书回忆要点，是促进组块形成的最好方法之一 在有限的时间制定明确的目标 做一个有判断力的读者 解决拖延 习惯 专注于过程上，而不是结果 每周在计划本里写下本周关键任务列表 每一天另起一页 在前一天晚上写好第二天的任务 将学习与其他人物夹杂能让每件事更富乐趣 高效，基础休息时间 尽量开始最重要且最讨厌的工作 良好的计划也是努力的一部分 ","date":"2022-08-07","objectID":"/posts/20221204-study/:0:0","tags":null,"title":"如何学习","uri":"/posts/20221204-study/"},{"categories":["note"],"content":"什么是计算机？ 计算机硬件的基本组成 CPU 中央处理器，负责计算机中所有的“计算” 内存 撰写的程序都需要加载到内存中才能运行，存放在内存中的程序需要被CPU读取，CPU计算完毕之后，还需要把数据写回到内存中。 主板 主板的芯片组和总线解决了CPU和内存之间如何通行。芯片组控制了数据传输的流转，总线则是数据传输的高速公路。 输入设备 鼠标、键盘 输出设备 显示器 冯诺依曼体系结构 =\u003e 存储程序计算机 存储程序计算机暗含了两个概念： 1. 可编程 2. 可存储 任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，所有现代计算机也都是基于这个基础架构来设计开发的。 ","date":"2019-08-13","objectID":"/posts/computer-composition/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/:0:1","tags":["计算机组成"],"title":"计算机组成-结构","uri":"/posts/computer-composition/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/"}]